"""
Handlers required by the web operations
"""

import uuid
import os
import json
import time
import hashlib
from yadacoin.basehandlers import BaseHandler
from yadacoin.graphutils import GraphUtils as GU
from yadacoin.blockchainutils import BU


class BaseWebHandler(BaseHandler):

    async def prepare(self):

        if self.request.protocol == 'http' and self.config.ssl:
            self.redirect('https://' + self.request.host + self.request.uri, permanent=False)
        
        await super(BaseWebHandler, self).prepare()


class HomeHandler(BaseHandler):

    async def get(self):
        """
        :return:
        """
        self.render(
            "index.html",
            yadacoin=self.yadacoin_vars,
            username=self.get_secure_cookie("username"),
            rid=self.get_secure_cookie("rid")
        )


class MultifactorAuthHandler(BaseHandler):
    async def get(self):
        redirect = self.get_query_argument('redirect', None)
        origin = self.get_query_argument('origin')
        if not origin:
            return '{"error": "origin not in query params"}', 400
        self.set_header("Access-Control-Allow-Origin", origin)
        self.set_header('Access-Control-Allow-Credentials', "true")
        self.set_header('Access-Control-Allow-Methods', "GET, POST, OPTIONS")
        self.set_header('Access-Control-Expose-Headers', "Content-Type")
        self.set_header('Access-Control-Allow-Headers', "Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, Cache-Control")
        self.set_header('Access-Control-Max-Age', 600)
        config = self.config
        rid = self.get_query_argument('rid')
        if not rid:
            return '{"error": "rid not in query params"}', 400

        txn_id = self.get_query_argument('id')

        cookie = self.get_secure_cookie("signin_code")
        if cookie:
            cookie = cookie.decode('utf-8')
        else:
            cookie = str(uuid.uuid4())
            self.set_secure_cookie("signin_code", cookie)

        result = await GU().verify_message(
            rid,
            cookie,
            config.public_key,
            txn_id.replace(' ', '+'))

        if result[1]:
            self.set_secure_cookie("rid", rid)

            username = await self.config.mongo.async_db.name_server.find_one({'rid': rid})
            self.set_secure_cookie("username", username['txn']['relationship']['their_username'])


            if redirect:
                return self.redirect(redirect)
            else:
                return self.render_as_json({
                    'authenticated': True
                })
        
        return self.render_as_json({
            'authenticated': False
        })

class LoginHandler(BaseHandler):

    async def get(self):
        origin = self.get_query_argument('origin')
        if not origin:
            return '{"error": "origin not in query params"}', 400
        
        # TODO: protect this endpoint with information that could only be generated by the identity!
        self.set_header("Access-Control-Allow-Origin", origin)
        self.set_header('Access-Control-Allow-Credentials', "true")
        self.set_header('Access-Control-Allow-Methods', "GET, POST, OPTIONS")
        self.set_header('Access-Control-Expose-Headers', "Content-Type")
        self.set_header('Access-Control-Allow-Headers', "Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, Cache-Control")
        self.set_header('Access-Control-Max-Age', 600)

        cookie = self.get_secure_cookie("signin_code")
        if cookie:
            cookie = cookie.decode('utf-8')
        else:
            cookie = str(uuid.uuid4())
            self.set_secure_cookie("signin_code", cookie)

        self.render_as_json({
            'signin_code': cookie
        })

class RemoteMultifactorAuthHandler(BaseHandler):
    async def post(self):
        args = json.loads(self.request.body.decode('utf-8'))
        origin = args.get('origin', '*')
        redirect = args.get('redirect')
        signin_code = args.get('signin_code')

        if not signin_code:
            return self.render_as_json({'error': 'missing params'}), 400
        self.set_header("Access-Control-Allow-Origin", origin)
        self.set_header('Access-Control-Allow-Credentials', "true")
        self.set_header('Access-Control-Allow-Methods', "GET, POST, OPTIONS")
        self.set_header('Access-Control-Expose-Headers', "Content-Type")
        self.set_header('Access-Control-Allow-Headers', "Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, Cache-Control")
        self.set_header('Access-Control-Max-Age', 600)
        config = self.config

        result = await self.config.mongo.async_db.verify_message_cache.find_one({
            'message.signIn': signin_code
        })

        if result:
            self.set_secure_cookie("rid", result['rid'])

            username = await self.config.mongo.async_db.name_server.find_one({'rid': result['rid']})
            self.set_secure_cookie("username", username['txn']['relationship']['their_username'])

            result = await self.config.mongo.async_db.verify_message_cache.delete_one({
                'message.signIn': signin_code
            })
            if redirect:
                return self.redirect(redirect)
            else:
                return self.render_as_json({
                    'authenticated': True
                })
        
        return self.render_as_json({
            'authenticated': False
        })


class TwoFactorAuthHandler(BaseWebHandler):

    async def post(self):
        """
        :return:
        """
        args = json.loads(self.request.body.decode('utf-8'))
        origin = args.get('origin', '*')
        redirect = args.get('redirect')
        auth_code = args.get('signin_code')


        if not auth_code:
            return self.render_as_json({'error': 'missing params'}), 400
        self.set_header("Access-Control-Allow-Origin", origin)
        self.set_header('Access-Control-Allow-Credentials', "true")
        self.set_header('Access-Control-Allow-Methods', "GET, POST, OPTIONS")
        self.set_header('Access-Control-Expose-Headers', "Content-Type")
        self.set_header('Access-Control-Allow-Headers', "Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, Cache-Control")
        self.set_header('Access-Control-Max-Age', 600)

        shared_secrets = self.config.GU.get_shared_secrets_by_rid(self.get_secure_cookie('rid').decode())
        authenticated = False
        for shared_secret in shared_secrets:
            hashed_shared_secret = hashlib.sha256(shared_secret).hexdigest()
            thirty_rounded_time = str(int(time.time()//30 * 30))
            result = int(hashlib.sha256((thirty_rounded_time + hashed_shared_secret).encode()).hexdigest(), 16) % (10 ** 6)
            if '000000{}'.format(result)[-6:] == auth_code:
                authenticated = True
                self.set_secure_cookie('2fa', 'true')
                break
            
        
        if redirect:
            return self.redirect(redirect)
        else:
            return self.render_as_json({
                'authenticated': authenticated
            })


class LogoutHandler(BaseHandler):

    def get(self):
        redirect = self.get_query_argument('redirect', None)

        if self.get_secure_cookie("signin_code"):
            self.set_secure_cookie("signin_code", '')

        if self.get_secure_cookie("rid"):
            self.set_secure_cookie("rid", '')

        if self.get_secure_cookie("username"):
            self.set_secure_cookie("username", '')

        if redirect:
            self.redirect(redirect)
        else:
            self.render_as_json({
                'authenticated': False
            })

class HashrateAPIHandler(BaseHandler):

    async def get(self):
        max_target = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        config = self.config
        blocks = config.BU.get_blocks()
        total_nonce = 0
        periods = []
        last_time = None
        for block in blocks:
            difficulty = max_target / int(block.get('target'), 16)
            if block.get('index') == 0:
                start_timestamp = block.get('time')
            if last_time:
                if int(block.get('time')) > last_time:
                    periods.append({
                        'hashrate': (((int(block.get('index')) / 144) * difficulty) * 2**32) / 600 / 100,
                        'index': block.get('index'),
                        'elapsed_time': (int(block.get('time')) - last_time)
                    })
            last_time = int(block.get('time'))
            total_nonce += block.get('nonce')
        sorted(periods, key=lambda x: x['index'])
        total_time_elapsed = int(block.get('time')) - int(start_timestamp)
        network_hash_rate =  total_nonce / int(total_time_elapsed)
        self.render_as_json({
            'stats': {
                'network_hash_rate': network_hash_rate,
                'total_time_elapsed': total_time_elapsed,
                'total_nonce': total_nonce,
                'periods': periods
            }
        })


class AppHandler(BaseWebHandler):

    async def get(self):
        """
        :return:
        """
        self.render("app.html")


class App2FAHandler(BaseWebHandler):

    async def prepare(self):
        if self.request.protocol == 'https':
            self.redirect('http://' + self.request.host + self.request.uri, permanent=False)

    async def get(self):
        """
        :return:
        """
        self.render("app2fa.html")


class GetRecoveryTransaction(BaseWebHandler):

    async def get(self):
        """
        :return:
        """
        rid = self.get_query_argument('rid')
        txn = await self.config.mongo.async_db.blocks.find_one({'transactions.rid': rid}, {'_id': 0})
        if not txn:
            txn = await self.config.mongo.async_db.miner_transactions.find_one({'rid': rid}, {'_id': 0})
        return self.render_as_json(txn)


WEB_HANDLERS = [
    (r'/', HomeHandler),
    (r'/mfa', MultifactorAuthHandler),
    (r'/login', LoginHandler),
    (r'/rmfa', RemoteMultifactorAuthHandler),
    (r'/2fa', TwoFactorAuthHandler),
    (r'/logout', LogoutHandler),
    (r'/api-stats', HashrateAPIHandler),
    (r'/app', AppHandler),
    (r'/app2fa', App2FAHandler),
    (r'/get-recovery-transaction', GetRecoveryTransaction),
]
